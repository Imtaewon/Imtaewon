# 💻 풀스택 개발자 임태원

> **"논리적 사고와 기술적 완성도로 사용자 중심의 서비스를 구현합니다"**

## 🔍 Profile

물리학 전공을 통해 키운 논리적 사고력과 체계적 분석 능력을 바탕으로, 백엔드부터 프론트엔드까지 전 영역에서 **완성도 높은 서비스**를 구현하는 것을 목표로 합니다.

### 📋 기본 정보
- **이메일**: imtaewon0123@gmail.com
- **연락처**: +82 10-9297-8097  
- **거주지**: 대전 유성구
- **학력**: 경북대학교 물리학과 (2018.03 - 2024.08)

### 🏆 자격증 & 수상
- **방재기사** (2024.12)
- **OPic IM1** (2025.09)
- **금융 해커톤 참가** (2025.08)

### 🎓 교육 이수

**SSAFY 13기 (2025.01 - 교육 중)**
- **기간**: 총 1년, 주 40시간 집중 교육
- **핵심 습득 내용**: 
  - 실무 중심 풀스택 개발: Spring Boot, React 기반 웹 애플리케이션 개발
  - 팀 프로젝트 경험: Agile 스프린트 계획, Jira 이슈 트래킹, Git 브랜치 전략 활용
  - 코드 품질 관리: 코드 리뷰, 품질 기준 수립, 배포 자동화를 통한 안정성 확보
- **도전의식 발현**: 6주간 팀 프로젝트에서 백엔드 개발 총괄을 맡아 8개 도메인 모듈을 독립적으로 설계하고 구현하며 확장 가능한 아키텍처 구축

---

## ⚒️ Tech Skills

**FastAPI** ⭐⭐⭐⭐
- Dependency Injection을 활용한 계층 분리
- SQLAlchemy ORM을 통한 복잡한 서브쿼리 최적화
- JWT + Redis 기반 인증 시스템 구축
- httpx를 활용한 외부 API 비동기 연동까지 end-to-end 구현 경험험

**React** ⭐⭐⭐⭐

- WebSocket 기반 실시간 UI 구현
- 컴포넌트 모듈화를 통한 12개 채팅 관련 컴포넌트 설계
- 메모이제이션과 가상화 스크롤링을 활용한 성능 최적화
- Zustand를 통한 전역 상태 관리

**JavaScript** ⭐⭐⭐
- WebSocket 이벤트 핸들러 및 다채로운 메시지 타입을 동적 객체로 설계·처리
- 복잡한 채팅 메시지 구조도 JS 객체와 동적 필드 관리로 유연하게 구현
- React에서 Props 전송 및 컴포넌트 연결에 능숙, 런타임 데이터 흐름 제어에 강점
- 코드 실행 과정과 비동기 이벤트 처리에 집중하며, 정적 타입보다 동적 구조와 실행 흐름 최적화에 경험이 많음

**Docker & 인프라** ⭐⭐⭐
- docker-compose로 5개 서비스(FastAPI, Nginx, MySQL, Redis, phpMyAdmin) 오케스트레이션
- 개발/배포 환경 분리
- Nginx 리버스 프록시 설정은 가능하지만 Kubernetes나 클라우드 네이티브 패턴은 학습 중

**WebSocket 통신** ⭐
- 연결 상태 관리(CONNECTING, CONNECTED, RECONNECTING, DISCONNECTED)
- 자동 재연결 로직
- 하트비트 메커니즘
- 토큰 만료 시 자동 처리까지 구현했지만 대용량 트래픽 처리나 클러스터링은 경험 부족

**MySQL & Redis** ⭐
- 기본적인 CRUD 작업과 인덱스 설정
- Redis Set을 활용한 블랙리스트 처리는 가능하지만 대용량 데이터 파티셔닝이나 성능 튜닝은 더 경험 필요

---

## 🚀 주요 프로젝트

## 🏆 쏠쏠한 퀘스트

### **요약**
💡 **"성장이 이자가 되고, 경쟁이 나눔이 되다"**

**프로젝트 개요**: 대학생들의 금융 활동과 일상 습관을 게이미피케이션으로 연결하여 퀘스트 완료를 통해 경험치를 획득하고 실제 금융 혜택을 제공하는 핀테크 서비스입니다.

**역할**: 4명 팀에서 백엔드 개발 총괄 및 인프라 담당으로 전체 시스템 아키텍처 설계와 구현을 주도했습니다.

**프로젝트 시기**: 2025년 8월 (2주간 집중 개발)

### **역할**

**프로젝트 전체 인원**: 총 4명으로 구성된 팀 "금리복잡도 O(1)"에서 진행했습니다. 팀 구성은 PM 및 데이터베이스 1명, 백엔드 및 인프라 1명(본인), AI 추천시스템 개발자 1명, 프론트엔드 개발자 1명으로 이루어졌습니다.

**나의 역할과 기여도**: **백엔드 개발 총괄 및 인프라 전담**으로서 전체 시스템의 기술적 기반을 단독으로 구축했습니다.

- **전체 백엔드 아키텍처 설계**: FastAPI 기반으로 8개 도메인 모듈(auth, quests, users, universities, accounts, attendance, recommend, surveys)을 완전 독립적으로 분리하여 각각 router-schemas-service 패턴으로 구현
- **복잡한 데이터베이스 설계**: SQLAlchemy를 활용하여 퀘스트-사용자-대학 간의 복잡한 관계형 모델링과 N+1 쿼리 최적화를 위한 서브쿼리 설계
- **SSAFY 금융 OpenAPI 완전 연동**: 계좌 개설부터 이체 처리까지 전체 금융 프로세스 구현, httpx 비동기 클라이언트를 활용한 외부 API 호출 안정성 확보
- **인프라 설계 및 구축**: Docker Compose를 활용한 5개 서비스 오케스트레이션 설계 (향후 확장 배포용), 실제 서비스는 systemd를 통한 서버 직접 배치
- **보안 시스템 구현**: JWT + Redis 블랙리스트를 활용한 로그아웃 토큰 즉시 무효화, bcrypt 기반 패스워드 해싱

*팀 내 기여도는 약 40%로, 전체 백엔드 시스템과 인프라를 단독으로 담당하며 프로젝트의 기술적 토대를 구축했습니다.*

### **아키텍처**
<img src="./아키텍처_최종수정.png" />



### **사용 기술 및 선택 이유**

**FastAPI + SQLAlchemy + Pydantic**
- **선택 근거**: 8개 도메인의 복잡한 비즈니스 로직과 실시간 퀘스트 처리에 고성능이 필요했습니다. 또한 프론트엔드 팀원과의 API 인터페이스 정의를 명확하게 하기 위해 자동 OpenAPI 스키마 생성이 필요했습니다.
- **구체적 활용**: Dependency Injection으로 계층 분리, Pydantic으로 타입 안전한 API 스키마 정의, SQLAlchemy의 aliased와 subquery를 활용한 복잡한 조인 최적화

**Redis (전용 블랙리스트)**
- **선택 근거**: JWT는 stateless 특성상 서버에서 토큰을 강제 무효화할 수 없는 문제가 있었습니다. 로그아웃된 토큰의 즉시 무효화를 위해 O(1) 성능의 인메모리 데이터베이스가 필요했습니다.
- **구체적 활용**: 토큰 생성 시 JTI(JWT ID)를 부여하고 로그아웃 시 Redis Set에 저장, 인증 확인 시마다 블랙리스트 조회를 통한 즉시 무효화 처리

**httpx 비동기 클라이언트**
- **선택 근거**: SSAFY 금융 OpenAPI 호출 시 동기식 requests 라이브러리를 사용하면 외부 API 응답 대기 중 다른 사용자 요청이 블로킹되는 문제가 발생했습니다. 외부 API 장애와 무관하게 서비스 안정성을 확보해야 했습니다.
- **구체적 활용**: 비동기 HTTP 호출로 외부 API와 내부 처리 분리, 재시도 로직과 타임아웃 설정으로 장애 격리

**Docker Compose (5개 서비스 오케스트레이션)**
- **선택 근거**: 팀원 간 개발 환경 일관성 확보와 향후 클라우드 배포 확장성을 고려했습니다. 실제 해커톤 서비스는 systemd로 직접 배포했지만, 추후 마이크로서비스 확장을 위한 컨테이너화 전략을 수립했습니다.
- **구체적 활용**: FastAPI, MySQL, Redis, Nginx, phpMyAdmin의 5개 서비스를 docker-compose.yml로 통합 관리, 개발 환경 즉시 구축 가능

### **구현사항**

**N+1 쿼리 최적화를 통한 복잡한 퀘스트 시스템**
- **과제**: 모든 퀘스트와 사용자별 최신 진행상태를 동시에 조회할 때 N+1 쿼리 문제 발생
- **해결**: SQLAlchemy의 `aliased`와 `subquery`를 조합하여 사용자별 최신 시도(attempt)를 서브쿼리로 구성한 후 `outerjoin`으로 단일 쿼리 처리

**8가지 검증 방식 통합 퀘스트 인증**
- GPS 위치 기반, 걸음 수, 링크 클릭, 파일 업로드, 결제 내역, 출석 체크, 자격증 인증, 대회 참여 등 8가지 검증 방식을 Enum 기반으로 타입 안전하게 통합 처리
- 사용자별 진행 상태 실시간 추적 및 중복 완료 방지 로직 구현

**SSAFY 금융 OpenAPI 완전 연동**
- **복잡한 헤더 자동 생성**: 시간 기반 고유 거래번호, 기관 코드, API 키 등을 포함한 복잡한 요청 헤더를 자동 생성하는 헬퍼 함수 구현
- **트랜잭션 기반 데이터 일관성**: 외부 API 호출과 내부 DB 저장을 하나의 트랜잭션으로 묶어 데이터 정합성 보장
- **비동기 처리로 성능 확보**: httpx를 활용하여 금융 API 호출 중에도 다른 사용자 요청 처리 가능

### **프로젝트 성과**

- **계좌 개설 API 연동 성공률 98%** 달성
- **SQLAlchemy 쿼리 최적화로 응답 속도 75% 향상** (1.2초 → 0.3초)
- **8개 도메인 모듈 완전 독립 분리**로 팀원 간 병렬 개발 실현
- **Docker 5개 서비스 설계**로 향후 마이크로서비스 확장 기반 구축
- **systemd 기반 실제 서비스 배포** 완료

### **문제 해결**

**문제 1: JWT 로그아웃 후 토큰 재사용 보안 취약점**

**오류 분석**: JWT는 서버에서 상태를 관리하지 않는 stateless 특성상 로그아웃 후에도 토큰 만료 전까지 계속 유효한 문제가 발생했습니다.

**개선 과정**:
1. 토큰 생성 시 고유 JTI(JWT ID) 부여
2. Redis Set을 활용한 블랙리스트 저장소 구현
3. 모든 인증 요청에서 O(1) 성능의 블랙리스트 조회 로직 추가

**전후 비교**: 로그아웃된 토큰의 재사용이 완전 차단되어 보안 취약점 해결, JWT의 확장성은 그대로 유지

**문제 2: 외부 금융 API 연동 시 시스템 블로킹**

**오류 분석**: 동기식 HTTP 클라이언트 사용으로 외부 API 응답 대기 중 모든 사용자 요청이 블로킹되는 현상 발생

**개선 과정**:
1. requests 라이브러리에서 httpx 비동기 클라이언트로 교체
2. 외부 API 호출과 내부 비즈니스 로직 분리
3. 타임아웃 설정과 재시도 로직 추가

**전후 비교**: 외부 API 장애와 무관하게 다른 사용자 요청 정상 처리, 전체 시스템 안정성 확보

### **프로젝트 회고**

**배운 점**
- **인프라 설계의 전략적 사고**: Docker 컨테이너 설계는 했지만 실제 배포는 systemd로 진행하면서, 현재 요구사항과 미래 확장성을 모두 고려한 기술 선택의 중요성을 깨달았습니다.
- **데이터베이스 쿼리 최적화**: SQLAlchemy ORM을 활용하면서도 성능을 위한 복잡한 서브쿼리 작성 능력을 기를 수 있었습니다.

**아쉬웠던 부분과 개선 방안**
- **테스트 코드 부족**: 2주라는 제한된 기간으로 인해 단위 테스트와 통합 테스트 작성이 미흡했습니다. 향후 프로젝트에서는 TDD 방법론을 적용하여 코드 품질을 높이고 싶습니다.
- **모니터링 시스템 부재**: 실제 운영 시 성능 지표나 에러 로그 추적이 어려웠습니다. 다음에는 초기부터 로깅과 모니터링 시스템을 구축할 예정입니다.

**깨달은 점**
백엔드와 인프라를 전담하면서 **시스템 전체를 조감하는 시야**의 중요성을 깨달았습니다. 단순히 기능 구현이 아닌 확장성, 유지보수성, 성능을 종합적으로 고려한 아키텍처 설계 능력이 핵심임을 확인했습니다.

---

## ☕ fik@ssafy

### **요약**
💡 **"만남과 대화가 시작되는 곳, 피카사피"**

**프로젝트 개요**: SSAFY 교육생들의 네트워킹과 교육을 지원하는 실시간 커뮤니티 플랫폼으로, WebSocket 기반 채팅과 WebRTC 화상채팅을 제공하는 서비스입니다.

**나의 역할**: 6명 팀에서 **프론트엔드 실시간 채팅 시스템 전담**으로 사용자 경험을 중심으로 한 UI/UX 구현을 주도했습니다.

**프로젝트 시기**: 2025년 7월 (6주간 개발)

### **역할**

**프로젝트 전체 인원**: 총 6명으로 구성된 팀에서 진행했습니다. 팀 구성은 프론트엔드 개발자 3명, 백엔드 개발자 3명으로 이루어졌습니다.

**나의 역할과 기여도**: **프론트엔드 실시간 채팅 시스템 전담**으로서 WebSocket 통신부터 채팅 UI/UX까지 채팅 관련 모든 기능을 독립적으로 구현했습니다.

- **WebSocket 서비스 설계**: 연결 상태 관리, 자동 재연결, 하트비트 메커니즘을 포함한 완전한 실시간 통신 시스템 구축
- **채팅 컴포넌트 모듈화**: 12개의 독립적인 채팅 관련 컴포넌트(ChatLayout, ChatContainer, MessageItem, MessageInput 등)로 세밀하게 분리
- **사용자 경험 최적화**: 메시지 전송 시 즉시 반응, 연속 메시지 그룹화, 스크롤 최적화 등 세심한 UX 고려
- **성능 최적화**: 가상화 스크롤링과 메모이제이션을 통한 대용량 메시지 처리

### **사용 기술 및 선택 이유**

**React**
- **선택 근거**: React는 컴포넌트 기반의 선언적 UI 설계를 지원하여, 실시간 채팅, 화면 상태 변화 등 동적인 SPA에서 최적의 생산성을 제공합니다. 높은 컴포넌트 재사용성과 Virtual DOM 기반의 렌더링 성능 덕분에, 100명 이상의 동접 환경에서도 성능 저하 없이 인터랙티브 UI를 구현할 수 있었습니다.
- **구체적 활용**: 컴포넌트 분할, UI 최적화, 성능 튜닝

**JavaScript**
- **선택 근거**: JavaScript는 브라우저 환경에서 표준적으로 실행되어 빠른 프로토타이핑과 다양한 라이브러리 및 Web API 활용이 용이합니다. 채팅 메시지 타입, 실시간 데이터 변환 등 클라이언트-서버 간 자유로운 데이터 처리를 유연하게 지원합니다.
- **구체적 활용**: 실시간 메시지 처리, 동적 데이터 변환, 브라우저 환경 최적화

**WebSocket + 연결 관리**
- **선택 근거**: HTTP 폴링으로는 다수의 동시 접속속 환경에서 실시간성과 성능 한계가 있었습니다. 네트워크 불안정이나 토큰 만료 상황에서도 안정적인 서비스 제공이 필요했습니다.
- **구체적 활용**: 4단계 연결 상태 관리(CONNECTING, CONNECTED, RECONNECTING, DISCONNECTED), 지수 백오프 기반 자동 재연결(최대 5회), 30초 간격 하트비트(PING/PONG)

**Zustand (실시간 상태 전용)**
- **선택 근거**: Redux보다 가벼우면서도 채팅방별 메시지, 사용자 목록, 읽지 않은 메시지 수 등 복잡한 실시간 상태를 효율적으로 관리해야 했습니다.
- **구체적 활용**: 채팅방별 마지막 메시지 업데이트, 전역 알림 상태 관리, 읽지 않은 메시지 수 자동 계산


### **구현사항**

**WebSocket 연결 관리 시스템**
- **4단계 연결 상태 관리**: CONNECTING → CONNECTED → RECONNECTING → DISCONNECTED 상태 추적
- **지수 백오프 재연결**: 1초 → 2초 → 4초 → 8초 → 16초 → 30초(최대) 간격으로 최대 5회 재연결 시도
- **하트비트 메커니즘**: 30초마다 PING 전송, 서버 PONG 응답 확인으로 연결 상태 실시간 모니터링
- **토큰 만료 자동 처리**: JWT 토큰 만료 시 자동으로 로그인 페이지 리다이렉트

**전역 알림 시스템**
- **GLOBAL_CHAT_NOTIFICATION 처리**: 현재 보고 있는 채팅방이 아닌 다른 채팅방의 메시지에 대한 실시간 알림
- **읽지 않은 메시지 수 자동 관리**: 채팅방 목록에서 각 방별 unread count 실시간 업데이트
- **마지막 메시지 미리보기**: 채팅방 목록에서 최신 메시지 내용과 발신자명 실시간 표시

**세밀한 사용자 경험 최적화**
- **즉시 메시지 반응**: 사용자 메시지 전송 시 임시 메시지를 즉시 화면에 표시하고 서버 응답 후 실제 메시지로 교체
- **연속 메시지 그룹화**: 같은 발신자의 연속 메시지를 시각적으로 그룹화하고 중복 정보(이름, 시간) 제거
- **날짜 구분선 자동 삽입**: 날짜가 변경될 때 자동으로 날짜 구분선 삽입
- **스크롤 위치 기억**: 새 메시지 도착 시 사용자가 이전 메시지를 읽고 있다면 자동 스크롤하지 않고 "새 메시지" 알림 표시

**12개 컴포넌트 모듈화**
- **ChatLayout**: 전체 채팅 레이아웃 관리, 반응형 사이드바
- **ChatContainer**: 개별 채팅방 컨테이너
- **MessageItem**: 개별 메시지 렌더링, 메모이제이션 적용
- **MessageInput**: 메시지 입력, 타이핑 상태 전송
- **ChatRoomList**: 채팅방 목록, 실시간 업데이트
- **기타 7개**: 헤더, 참여자 모달, 이미지 모달 등 세부 기능

### **프로젝트 성과**

- **107명 동시 접속** 환경에서 안정적 서비스 제공
- **실시간 메시지 전달률 99.5%** 달성
- **사용자 만족도 90% 이상** 달성 (서비스 운영 중 피드백)

### **문제 해결**

**문제 1: 대용량 채팅 메시지 렌더링 성능 저하**

**오류 분석**: 1000개 이상 메시지 누적 시 모든 DOM 요소를 렌더링하여 스크롤 성능이 급격히 저하되고 메모리 사용량이 급증하는 문제 발생

**개선 과정**:
1. **React.memo를 활용한 메시지 컴포넌트 메모이제이션**: props가 변경되지 않은 메시지는 리렌더링 방지
2. **가상화 스크롤링 도입 검토**: react-window 라이브러리 적용하여 화면에 보이는 메시지만 렌더링
3. **메시지 lazy loading 구현**: 스크롤 위치에 따라 이전 메시지 동적 로딩

**전후 비교**:
- 1000개 메시지 기준 렌더링 시간: 3.2초 → 0.8초 (**75% 성능 향상**)
- 스크롤 응답성: 끊김 현상 완전 해결

**해결 과정 서술**: 초기에는 채팅의 특성상 모든 메시지를 보여줘야 한다고 생각했으나, 실사용에서는 최근 메시지만 주로 확인한다는 점을 깨달았습니다. 가상화 개념을 학습하고 적용하면서 프론트엔드 성능 최적화에 대한 근본적 이해를 얻을 수 있었습니다.

**문제 2: WebSocket 연결 불안정으로 인한 메시지 손실**

**오류 분석**: 네트워크 불안정이나 브라우저 탭 전환 시 WebSocket 연결이 끊어지면서 메시지 손실 및 실시간성 저하 문제 발생

**개선 과정**:
1. **연결 상태 세밀한 추적**: CONNECTING, CONNECTED, RECONNECTING, DISCONNECTED 4단계로 상태 관리
2. **지수 백오프 재연결 로직**: 1초부터 시작하여 최대 30초까지 간격을 늘려가며 최대 5회 재연결 시도
3. **하트비트 메커니즘**: 30초마다 PING/PONG으로 연결 상태 실시간 확인
4. **토큰 만료 자동 감지**: JWT 토큰 만료 시 자동으로 인증 페이지 이동

**전후 비교**: 네트워크 불안정 상황에서도 **99.5%의 메시지 전달률** 달성, 사용자 경험 중단 없는 자동 복구

### **프로젝트 회고**

**배운 점**
- **실시간 통신의 복잡성**: 단순한 WebSocket 연결을 넘어 연결 상태 관리, 재연결, 메시지 순서 보장 등 고려할 요소가 매우 많다는 것을 실전에서 체감했습니다.
- **성능 최적화의 중요성**: 소규모 테스트에서는 문제없던 코드가 실제 사용자 증가 시 성능 병목이 되면서, 최적화 기법의 필요성을 절실히 깨달았습니다.

**아쉬웠던 부분과 개선 방안**
- **에러 핸들링 체계성 부족**: WebSocket 연결 실패나 메시지 전송 실패 시 사용자에게 제공하는 피드백이 일관성 없었습니다. 향후에는 에러 타입별 명확한 사용자 알림 체계를 구축하고 싶습니다.
- **접근성 고려 부족**: 키보드 네비게이션, 스크린 리더 지원 등 웹 접근성을 충분히 고려하지 못했습니다.

**깨달은 점**
**프론트엔드 채팅 시스템 전담**을 통해 실시간 웹 애플리케이션의 복잡성과 사용자 경험의 중요성을 깊이 이해할 수 있었습니다. "다른 플랫폼보다 뒤처지지 않는다"는 사용자 피드백을 받았을 때, 세밀한 UX 고려가 실제 사용자 만족도로 직결됨을 확인했습니다. 기술 구현 자체보다도 **사용자가 실제로 편리함을 느끼는지**가 더 중요하다는 핵심을 깨달았습니다.

---

## 📞 Contact

**이메일**: imtaewon0123@gmail.com  
**연락처**: +82 10-9297-8097  
**GitHub**: [github.com/imtaewon](https://github.com/imtaewon)

---

*"기술은 결국 사람을 위한 도구입니다. 사용자의 불편함을 찾아내고 해결하는 과정에서 성장하며, 배려가 담긴 기술로 더 나은 경험을 만드는 개발자가 되겠습니다."*
