# 💻 풀스택 개발자 임태원

> **"논리적 사고와 기술적 완성도로 사용자 중심의 서비스를 구현합니다"**

## 🔍 Profile

물리학 전공을 통해 키운 논리적 사고력과 체계적 분석 능력을 바탕으로, 백엔드부터 프론트엔드까지 전 영역에서 **완성도 높은 서비스**를 구현하는 것을 목표로 합니다.

### 📋 기본 정보
- **이메일**: imtaewon0123@gmail.com
- **연락처**: +82 10-9297-8097  
- **거주지**: 대전 유성구
- **학력**: 경북대학교 물리학과 (2018.03 - 2024.08)

### 🏆 자격증 & 수상
- **방재기사** (2024.12)
- **OPic IM1** (2025.09)
- **신한은행 해커톤 참가** (2025.08)

### 🎓 교육 이수

**삼성 SW/AI 아카데미(SSAFY) 13기 (2025.01 - 교육 중)**
- **기간**: 총 1년, 주 40시간 집중 교육
- **핵심 습득 내용**: 
  - 실무 중심 풀스택 개발: FastAPI, React, React Native 기반 웹, 앱 애플리케이션 개발
  - 팀 프로젝트 경험: Agile 스프린트 계획, Jira 이슈 트래킹, Git 브랜치 전략 활용
  - 코드 품질 관리: 코드 리뷰, 품질 기준 수립, 배포 자동화를 통한 안정성 확보

---

## ⚒️ Tech Skills

**FastAPI** ⭐⭐⭐⭐
- Dependency Injection을 활용한 계층 분리
- SQLAlchemy ORM을 통한 복잡한 서브쿼리 최적화
- JWT + Redis 기반 인증 시스템 구축
- httpx를 활용한 외부 API 비동기 연동까지 end-to-end 구현 경험험

**React** ⭐⭐⭐⭐

- WebSocket 기반 실시간 UI 구현
- 컴포넌트 모듈화를 통한 12개 채팅 관련 컴포넌트 설계
- 메모이제이션과 가상화 스크롤링을 활용한 성능 최적화
- Zustand를 통한 전역 상태 관리

**JavaScript** ⭐⭐⭐
- WebSocket 이벤트 핸들러 및 다채로운 메시지 타입을 동적 객체로 설계·처리
- 복잡한 채팅 메시지 구조도 JS 객체와 동적 필드 관리로 유연하게 구현
- React에서 Props 전송 및 컴포넌트 연결에 능숙, 런타임 데이터 흐름 제어에 강점
- 코드 실행 과정과 비동기 이벤트 처리에 집중하며, 정적 타입보다 동적 구조와 실행 흐름 최적화에 경험이 많음

**Docker & 인프라** ⭐⭐⭐⭐
- Docker Compose로 9개 마이크로서비스 오케스트레이션
- Jenkins CI/CD 파이프라인 구축 및 자동 배포
- Nginx 리버스 프록시 설정 및 SSL 적용
- AWS EC2 인프라 관리 및 모니터링 시스템 구축

**WebSocket 통신** ⭐⭐
- 연결 상태 관리(CONNECTING, CONNECTED, RECONNECTING, DISCONNECTED)
- 자동 재연결 로직
- 하트비트 메커니즘
- 토큰 만료 시 자동 처리까지 구현했지만 대용량 트래픽 처리나 클러스터링은 경험 부족

**MySQL & Redis** ⭐
- 기본적인 CRUD 작업과 인덱스 설정
- Redis Set을 활용한 블랙리스트 처리는 가능하지만 대용량 데이터 파티셔닝이나 성능 튜닝은 더 경험 필요

---

## 🚀 주요 프로젝트

## 💰 Dollar In$ight

### **요약**
💡 **"AI 페르소나와 함께하는 스마트 투자 플랫폼"**

**프로젝트 개요**: 한국 투자자를 위한 AI 기반 미국 주식 분석 플랫폼으로, 5개의 서로 다른 AI 투자 전문가(페르소나)와 실시간 채팅을 통해 다각도 투자 인사이트를 제공하는 서비스입니다. 단순한 정보 제공을 넘어 실제 투자 토론처럼 자연스러운 대화를 통해 투자 시야를 넓히는 것이 핵심입니다.

**역할**: 6명 팀에서 **인프라 전담**, 추가로 **프론트엔드 API 연동 및 실시간 채팅 시스템**을 구현했습니다.

**프로젝트 시기**: 2025년 10월 ~ 11월 (6주간 개발)

---

### **역할**

**프로젝트 전체 인원**: 총 6명으로 구성된 팀에서 진행했습니다. 팀 구성은 팀 리더 겸 프론트엔드 1명, 백엔드 2명, AI 서비스 1명, 프론트엔드 1명, 인프라 1명으로 이루어졌습니다.

**나의 역할과 기여도**: **인프라 전담**으로서 전체 시스템 아키텍처 설계부터 배포 자동화까지 담당했습니다.

**인프라 (80%):**
- **Docker 기반 마이크로서비스 오케스트레이션**: 9개 서비스(PostgreSQL, MongoDB, Redis, ChromaDB, Spring Boot, FastAPI, Nginx, Prometheus, Grafana) 통합 관리
- **Jenkins CI/CD 파이프라인 구축**: GitLab Webhook 연동, 자동 빌드/테스트/배포, 무중단 배포 구현
- **AWS EC2 인프라 관리**: 단일 인스턴스 최적화, 보안 그룹 설정, SSL/HTTPS 적용
- **Nginx 리버스 프록시 설정**: 로드 밸런싱, SSL 터미네이션, API 라우팅, SSE 스트리밍 최적화
- **모니터링 시스템 구축**: Prometheus + Grafana 대시보드, Docker 컨테이너 헬스 체크, 시스템 메트릭 수집

**프론트엔드 개발 (20%):**
- **실시간 채팅 API 연동**: SSE(Server-Sent Events) 기반 스트리밍 처리, 연결 상태 관리, 자동 재연결 로직
- **Flutter Provider 패턴 구현**: 채팅 상태 관리, 세션 관리, 메시지 큐 처리
- **RESTful API 통합**: 인증, 사용자 관리, 종목 조회 등 백엔드 API와의 완전 연동

*팀 내 기여도는 약 35%로, 전체 시스템의 안정성과 확장성을 책임지며 실시간 서비스의 기술적 완성도를 담당했습니다.*

---

### **아키텍처 및 시스템 설계**

**마이크로서비스 아키텍처**
![아키텍처](시스템아키텍처.png)

**핵심 설계 특징**:
- **단일 EC2 최적화**: t3.xlarge 인스턴스에서 모든 서비스를 효율적으로 운영
- **SSE 스트리밍**: AI 응답을 실시간으로 토큰 단위 스트리밍 처리
- **다중 데이터베이스**: 각 데이터 타입에 최적화된 데이터베이스 선택
- **Docker 네트워크 격리**: 서비스 간 안전한 내부 통신

---

### **사용 기술 및 선택 이유**

**Docker & Docker Compose**
- **선택 근거**: 6개 팀원이 서로 다른 개발 환경에서 작업하면서도 일관된 개발/배포 환경을 보장해야 했습니다. 또한 9개의 서로 다른 서비스를 단일 인스턴스에서 효율적으로 관리하기 위해 컨테이너화가 필수적이었습니다.
- **구체적 활용**: 서비스별 독립적인 Dockerfile 작성, docker-compose.yml로 전체 서비스 오케스트레이션, 네트워크 및 볼륨 관리

**Jenkins CI/CD**
- **선택 근거**: GitLab과의 완벽한 연동을 통해 코드 변경 시 자동으로 빌드/테스트/배포가 이루어져야 했습니다. 특히 AI 모델 업데이트, 백엔드 API 수정, 프론트엔드 배포가 빈번하게 일어나는 환경에서 수동 배포는 비효율적이었습니다.
- **구체적 활용**: Jenkinsfile 기반 파이프라인, Docker 이미지 자동 빌드/푸시, 무중단 배포, 롤백 기능, Slack 알림 연동

**Nginx 리버스 프록시**
- **선택 근거**: Spring Boot와 FastAPI 두 개의 백엔드 서비스를 하나의 도메인으로 통합하고, SSL 터미네이션과 로드 밸런싱을 처리해야 했습니다. 특히 SSE 스트리밍을 지원하려면 WebSocket과 유사한 프록시 설정이 필요했습니다.
- **구체적 활용**: API 라우팅 (/api → Spring Boot, /ai → FastAPI), SSE 프록시 설정, gzip 압축, 정적 파일 서빙

**멀티 데이터베이스 전략**
- **선택 근거**: 사용자 정보(PostgreSQL), 실시간 채팅(MongoDB), 캐싱(Redis), AI 벡터 검색(ChromaDB) 각각의 특성에 맞는 최적화된 데이터베이스가 필요했습니다. 단일 DB로는 성능과 확장성에 한계가 있었습니다.
- **구체적 활용**: PostgreSQL의 트랜잭션, MongoDB의 문서 저장, Redis의 고속 캐싱, ChromaDB의 벡터 유사도 검색

---

### **구현사항**

**1. Docker 기반 마이크로서비스 오케스트레이션**
- **9개 서비스 통합 관리**: PostgreSQL, MongoDB, Redis, ChromaDB, Spring Boot, FastAPI, Nginx, Prometheus, Grafana
- **의존성 관리**: depends_on과 healthcheck를 통한 서비스 시작 순서 제어
- **리소스 최적화**: CPU 및 메모리 limit 설정으로 단일 EC2에서 안정적 운영
- **네트워크 격리**: Docker 네트워크를 통한 서비스 간 안전한 내부 통신
- **볼륨 관리**: 데이터 영속성을 위한 named volume 활용

**2. Jenkins CI/CD 파이프라인 자동화**
- **GitLab Webhook 연동**: 코드 푸시 시 자동 빌드 트리거
- **멀티 스테이지 빌드**: 백엔드(Gradle) + AI서비스(Python) + 프론트엔드(Flutter) 병렬 빌드
- **Docker 이미지 관리**: 자동 태깅, Docker Hub 푸시, 이미지 정리
- **무중단 배포**: Blue-Green 방식으로 서비스 중단 없이 배포
- **자동 롤백**: 헬스체크 실패 시 이전 버전으로 자동 복구
- **알림 시스템**: 빌드 성공/실패 시 Slack 채널 자동 알림

**3. Nginx 고급 프록시 설정**
- **API 라우팅**: 경로 기반 백엔드 분산 (/api → Spring Boot:8080, /ai → FastAPI:8000)
- **SSE 스트리밍 지원**: Server-Sent Events를 위한 특수 헤더 설정과 프록시 최적화
- **SSL/HTTPS 적용**: Let's Encrypt 자동 인증서 갱신, HTTP/2 지원
- **성능 최적화**: gzip 압축, 캐시 헤더 설정, 정적 파일 최적화
- **보안 강화**: DDoS 방어, rate limiting, 보안 헤더 적용

**4. 보안 및 운영**
- **AWS 보안 설정**: VPC, Security Group, IAM 역할 기반 접근 제어
- **방화벽 구성**: UFW를 통한 필수 포트만 개방 (22, 80, 443)
- **비밀 정보 관리**: 환경변수를 통한 API Key, DB 패스워드 관리
- **백업 전략**: 데이터베이스 일일 자동 백업, 설정 파일 Git 관리
- **SSL/TLS**: Let's Encrypt 자동 갱신, HTTPS 강제 리다이렉트

**5. 모니터링 및 관찰 가능성**
- **Prometheus 메트릭 수집**: 시스템 리소스, 애플리케이션 성능, Docker 컨테이너 상태
- **Grafana 대시보드**: 실시간 시스템 상태, 트래픽 분석, 알림 설정
- **로그 집중화**: Docker logs 수집, 에러 추적, 성능 분석
- **헬스체크 자동화**: 모든 서비스의 /health 엔드포인트 모니터링

**6. SSE 기반 실시간 채팅 시스템**
- **스트리밍 연결 관리**: 연결 상태 추적, 자동 재연결, 하트비트 메커니즘
- **Flutter SSE 클라이언트**: Dio를 활용한 SSE 파싱, 이벤트 타입별 처리
- **메시지 큐 처리**: AI 응답을 토큰 단위로 실시간 스트리밍
- **세션 관리**: 채팅방별 독립적인 SSE 세션, 중복 연결 방지
- **에러 처리**: 네트워크 장애 시 자동 복구, 메시지 손실 방지
- **SSE flow**:
  ![SSE flow](SSE_flow.png)

---

### **프로젝트 성과**

- **100% 무중단 서비스**: Jenkins CI/CD로 총 47회 배포 중 서비스 중단 없음
- **9개 서비스 안정 운영**: 단일 EC2에서 평균 CPU 사용률 65%, 메모리 사용률 78% 유지
- **실시간 스트리밍 구현**: SSE 연결 성공률 99.2%, 평균 응답 시간 85ms 달성
- **모니터링 체계 구축**: Grafana 대시보드로 24/7 시스템 상태 추적, 장애 예방
- **팀 생산성 향상**: 배포 자동화로 수동 작업 90% 감소, 개발자 배포 시간 단축

---

### **문제 해결**

**문제 1: Docker 컨테이너 간 네트워크 통신 불안정**

**오류 분석**: 초기에 서비스명으로 컨테이너 간 통신을 시도했지만, DNS 해석 실패와 연결 타임아웃이 빈발했습니다. 특히 Spring Boot에서 PostgreSQL 연결 시 "Connection refused" 에러가 반복적으로 발생했습니다.

**개선 과정**:
1. **Docker 네트워크 디버깅**: docker exec으로 컨테이너 내부 접속 후 nslookup, ping 테스트
2. **의존성 순서 재설계**: depends_on과 healthcheck를 조합하여 데이터베이스 완전 준비 후 애플리케이션 시작
3. **연결 재시도 로직**: 애플리케이션 레벨에서 DB 연결 실패 시 지수 백오프로 재시도 구현
4. **네트워크 격리**: docker-compose.yml에서 명시적 네트워크 정의로 서비스 간 통신 안정화

**전후 비교**: 컨테이너 시작 실패율 35% → 1% 미만으로 감소, 개발팀의 로컬 환경 구축 시간 2시간 → 15분으로 단축

**문제 2: SSE 연결이 Nginx 프록시에서 중단되는 현상**

**오류 분석**: AI 응답 스트리밍 중 연결이 임의로 끊어지는 현상이 발생했습니다. 특히 1분 이상의 긴 응답에서 "502 Bad Gateway" 에러가 나타났습니다. 이는 Nginx의 기본 프록시 타임아웃 설정이 SSE에 최적화되지 않았기 때문이었습니다.

**개선 과정**:
1. **프록시 타임아웃 조정**: proxy_read_timeout을 86400s로 확장하여 장시간 연결 지원
2. **SSE 전용 헤더 설정**: "X-Accel-Buffering: no"로 nginx 버퍼링 비활성화
3. **Connection 헤더 설정**: "Connection: keep-alive"로 연결 유지 강제
4. **하트비트 메커니즘**: 30초마다 빈 이벤트 전송으로 연결 활성 상태 유지

**전후 비교**: SSE 연결 안정성 73% → 99.2%로 향상, 긴 AI 응답에서도 연결 끊김 없음

**문제 3: 배포 시 서비스 간 시작 순서 이슈로 인한 의존성 오류**

**오류 분석**: docker compose up 시 PostgreSQL이 완전히 준비되기 전에 Spring Boot가 시작되어 DB 연결 실패로 애플리케이션이 크래시하는 문제가 반복되었습니다. 특히 첫 배포나 재시작 시 이 문제가 심각했습니다.

**개선 과정**:
1. **헬스체크 구현**: 모든 DB 서비스에 대해 상태 확인 스크립트 작성
2. **의존성 체인 설계**: PostgreSQL → MongoDB → Redis → ChromaDB → Backend → AI Service 순서로 시작
3. **애플리케이션 레벨 대응**: Spring Boot에서 @Retryable 어노테이션으로 DB 연결 재시도
4. **Jenkins 배포 스크립트 개선**: 각 서비스 헬스체크 통과 확인 후 다음 단계 진행

**전후 비교**: 배포 성공률 68% → 100%로 향상, 배포 시간 예측 가능성 확보

---

### **프로젝트 회고**

**배운 점**
- **인프라 전체 관점의 중요성**: 단순히 서버를 띄우는 것이 아니라, 개발팀의 생산성과 서비스의 안정성을 모두 고려한 통합적 설계가 필요함을 깨달았습니다.
- **실시간 서비스의 복잡성**: SSE 스트리밍 하나를 구현하기 위해 Nginx 프록시, 네트워크 설정, 클라이언트 상태 관리까지 전체 스택을 이해해야 함을 경험했습니다.
- **모니터링의 필수성**: 문제 발생 전에 예측하고 대응하는 것이 사후 처리보다 훨씬 효율적임을 체감했습니다.

**아쉬웠던 부분과 개선 방안**
- **로그 분석 자동화 부족**: 현재는 수동으로 로그를 확인하고 있는데, ELK Stack 도입으로 로그 분석 자동화를 구현하고 싶습니다.
- **스케일링 대응 부족**: 단일 EC2 인스턴스 구조로 인한 확장성 한계가 있어, 향후 Kubernetes나 ECS 도입을 고려해야 합니다.

**깨달은 점**
**인프라는 개발팀의 창작 도구**라는 관점을 갖게 되었습니다. 안정적이고 효율적인 인프라 위에서 개발자들이 비즈니스 로직에 집중할 수 있도록 지원하는 것이 인프라 엔지니어의 핵심 역할임을 확인했습니다. 또한 실시간 서비스는 단순한 기능 구현을 넘어 전체 시스템의 조화가 중요하다는 것을 깊이 이해할 수 있었습니다.

---

## 🌤️WEATHEREVER

### **요약**
💡 **"whenever, wherever WEATHEREVER"**

**프로젝트 개요**: 위치 기반 실시간 날씨 정보와 AI 의류 추천을 결합한 스마트 날씨 도우미 서비스입니다. 단순히 현재 날씨만 보여주는 것이 아니라, 사용자의 위치와 일정을 고려하여 적절한 옷차림과 준비물을 시각적 캐릭터와 함께 제안합니다.

**역할**: 6명 팀에서 **프론트엔드 개발 전담**으로 React Native 기반의 전체 클라이언트 애플리케이션을 독립적으로 설계하고 구현했습니다.

**프로젝트 시기**: 2025년 9월 (4주간 개발)

---

### **역할**

**프로젝트 전체 인원**: 총 6명으로 구성된 팀에서 진행했습니다. 팀 구성은 프론트엔드 2명, 백엔드 1명, 인프라 1명, 엔지니어링 2명으로 이루어졌습니다.

**나의 역할과 기여도**: **프론트엔드 개발 전담**으로서 React Native 기반의 전체 UI/UX와 클라이언트 로직을 담당했습니다.

- **Atomic Design 패턴 완전 구현**: atoms(23개) → molecules(17개) → organisms(4개) → templates 구조로 전체 컴포넌트를 체계적으로 설계
- **3개 메인 화면 설계 및 구현**: 메인 날씨 화면, 대시보드(날씨 예보/교통 정보), 설정 화면을 사용자 중심으로 설계
- **복잡한 상태 관리 시스템**: Zustand를 활용하여 날씨, 의류 추천, 사용자 설정 등 5개 독립적인 store 구축
- **5개 외부 API 완전 연동**: 날씨 API, 의류 추천 API, 교통 정보 API, 위치 검색 API, 사용자 설정 API를 비동기 에러 처리와 함께 통합
- **위치 기반 서비스 완전 구현**: GPS 권한 관리, 자동 위치 감지, 수동 위치 검색, 캐싱 전략까지 포괄적으로 구현
- **반응형 레이아웃 시스템**: 디바이스 크기에 따른 동적 레이아웃 계산으로 모든 화면 크기 지원

*팀 내 기여도는 약 30%로, 전체 프론트엔드 시스템을 단독으로 설계하고 구현하며 사용자 경험의 완성도를 책임졌습니다.*

---

### **사용 기술 및 선택 이유**

**React Native (Expo)**
- **선택 근거**: 크로스 플랫폼(iOS/Android) 동시 지원으로 개발 생산성을 극대화해야 했습니다. Expo의 강력한 기본 라이브러리(위치, 권한, 폰트 등)를 활용하여 네이티브 기능 통합 시간을 대폭 단축할 수 있었습니다.
- **구체적 활용**: Expo Location으로 GPS 및 권한 관리, Expo Font로 커스텀 폰트 적용, SafeAreaView로 노치 영역 대응

**TypeScript**
- **선택 근거**: 5개 API의 복잡한 데이터 구조와 23개 atom 컴포넌트의 props 타입 안정성을 보장해야 했습니다. 런타임 에러를 컴파일 단계에서 사전 차단하여 안정성을 확보했습니다.
- **구체적 활용**: 모든 API 응답에 대한 인터페이스 정의, 엄격한 타입 추론으로 props 전달 오류 방지, 제네릭을 활용한 재사용 가능한 유틸리티 함수

**Zustand**
- **선택 근거**: 날씨, 의류, 위치, 사용자 설정 등 여러 독립적인 상태를 관리하면서도 Redux의 보일러플레이트 없이 간결한 코드를 유지해야 했습니다. 미들웨어 없이도 비동기 액션을 직관적으로 처리할 수 있었습니다.
- **구체적 활용**: 5개의 독립적인 커스텀 훅(useWeatherStore, useClothingStore 등)으로 관심사 분리, API 호출과 에러 처리를 store 내에서 캡슐화

**Atomic Design Pattern**
- **선택 근거**: 23개의 재사용 가능한 atom 컴포넌트를 만들어 일관된 UI와 빠른 기능 추가가 필요했습니다. 디자인 시스템 변경 시 단일 atom만 수정하면 전체 앱에 반영되는 확장성을 확보했습니다.
- **구체적 활용**: Button, Text, Icon 등 기본 atoms → WeatherCard, TabBar 등 molecules → WeatherDisplay, SettingsSection 등 organisms로 체계적 조립

**Custom Hooks 패턴**
- **선택 근거**: 위치 정보, 권한 관리, 레이아웃 계산 등 반복되는 로직을 재사용하고 컴포넌트를 순수하게 유지해야 했습니다. 비즈니스 로직과 UI를 명확히 분리하여 테스트 가능성을 높였습니다.
- **구체적 활용**: useLocation(위치 관리), useLocationPermission(권한), useDeviceLayout(반응형), useTrafficInfo(교통 정보) 등 8개 커스텀 훅 구현

### 실행 화면
<img src="./weatherever.png">

### **구현사항**

**1. 위치 기반 스마트 날씨 시스템**
- **GPS 자동 감지 + 수동 검색 하이브리드**: 사용자가 권한을 거부해도 수동으로 지역을 검색하여 날씨를 확인할 수 있도록 구현
- **위치 데이터 캐싱 전략**: 불필요한 GPS 요청을 줄이기 위해 최근 위치를 Zustand에 캐싱하고 30분마다 자동 갱신
- **3단계 지오코딩 시스템**: 좌표 → 지역명 변환을 위해 Google Geocoding API를 우선 사용하고 실패 시 Nominatim API로 폴백

**2. 복합 API 통합 및 에러 처리**
- **5개 외부 API 완전 통합**: 날씨(`/weather`), 의류 추천(`/weather/cloth`), 시간별 예보(`/weather/forecast`), 교통 정보(`/traffic-info`), 사용자 설정(`/user`)
- **통합 에러 핸들링 시스템**: withErrorHandling 유틸리티로 모든 API 호출을 래핑하여 네트워크 에러, 타임아웃, 파싱 에러를 통합 처리
- **재시도 전략**: API 실패 시 pending 상태로 변경사항을 로컬에 저장하고 다음 성공 시 자동 동기화
- **타임아웃 설정**: 각 API에 10초 타임아웃을 설정하여 무한 대기 방지

**3. 날씨 기반 의류 + 액세서리 추천 시스템**
- **3단계 의류 추천**: 백엔드에서 온도/습도/강수량을 분석하여 short(반팔)/long(긴팔)/outter(외투) 중 추천
- **조건부 액세서리 표시**: 비 예보(rainInfo), 높은 UV 지수(uvInfo), 나쁜 대기오염(airPollutionInfo)에 따라 우산☂️, 선크림☀️, 마스크🌫️ 자동 표시
- **인터랙티브 툴팁**: 각 액세서리를 터치하면 해당 기후 정보(예: "UV 지수: 매우높음")를 말풍선 스타일로 표시
- **GIF 기반 캐릭터 시스템**: 의류 타입에 따라 다른 캐릭터 GIF를 동적으로 로드하여 시각적 피드백 제공

**4. 시간별 날씨 예보 대시보드**
- **24시간 시간별 예보**: 현재 시각부터 24시간 동안의 온도, 날씨 아이콘, 강수확률, 바람, 습도, 미세먼지 정보를 카드 형식으로 제공
- **현재 시각 강조**: 가장 위쪽 카드를 "지금"으로 표시하고 다른 시각보다 시각적으로 강조
- **Pull-to-Refresh**: 아래로 당겨서 최신 예보 데이터 새로고침 기능

**5. 교통 정보 통합 대시보드**
- **주요 경로 실시간 상태**: 사용자 위치 기준 주변 주요 도로의 교통 상황(원활/보통/정체/차단) 표시
- **속도 기반 상태 계산**: 평균 속도를 기준으로 교통 상태를 자동 분류 (40km/h 이상 = 원활, 15km/h 미만 = 차단)
- **소요 시간 예측**: 거리와 평균 속도를 기반으로 예상 소요 시간을 분 단위로 계산하여 표시
- **색상 코딩**: 교통 상태에 따라 카드 색상을 다르게 표시 (초록=원활, 노랑=보통, 빨강=정체)

**6. 사용자 맞춤 설정 시스템**
- **근무시간 설정**: TimePicker로 출근/퇴근 시각을 설정하면 해당 시간 전에 날씨 알림 제공 준비
- **더위/추위 선호도**: 사용자 체감에 따라 "더움/보통/추움"을 설정하면 백엔드가 이를 고려한 의류 추천
- **실시간 동기화**: 설정 변경 시 즉시 서버에 PUT 요청을 보내고 로컬 상태와 서버 상태를 동기화
- **Pending Changes 관리**: 네트워크 실패 시 변경사항을 로컬에 저장하고 다음 성공 시 자동 업로드

**7. Atomic Design 기반 컴포넌트 시스템**
- **23개 Atoms**: Button, Text, Icon, Card, WeatherIcon, TimePicker, Dropdown 등 최소 단위 컴포넌트
- **17개 Molecules**: Header, WeatherCard, TabBar, MessageBanner, LocationSearchInput, TrafficRouteCard 등 조합 컴포넌트
- **4개 Organisms**: WeatherDisplay(3단 분할), SettingsSection, WeatherSection, AnalyticsSection 등 복잡한 블록
- **완전한 모듈화**: 각 컴포넌트는 독립적인 폴더에 .tsx 파일과 index.ts를 가지며, props 인터페이스를 명확히 정의

---

### **프로젝트 성과**

- **5개 외부 API 완전 통합** 및 통합 에러 처리 시스템 구축
- **23개 재사용 가능한 Atom 컴포넌트** 설계로 일관된 UI 시스템 확립
- **GPS 권한 거부율 0%**: 수동 위치 검색 대안 제공으로 모든 사용자가 서비스 이용 가능
- **API 응답 시간 최적화**: 위치 캐싱으로 불필요한 GPS 요청 75% 감소
- **안정적인 상태 관리**: Zustand 기반 5개 독립 store로 복잡한 데이터 플로우 관리

---

### **문제 해결**

**문제 1: 복잡한 날씨 상태 판단 로직**

**오류 분석**: 초기에는 백엔드에서 받은 precipitationType("없음", "비", "눈" 등)만으로 날씨를 판단했는데, 실제 강수량이 0인데도 "비"로 표시되거나 높은 습도 상황을 반영하지 못하는 문제가 발생했습니다.

**개선 과정**:
1. precipitationType, 실제 강수량(oneHourPrecipitation), 습도 3가지를 모두 고려하는 `determineWeatherCondition` 함수 구현
2. 우선순위 기반 판단 로직: 실제 강수량(1순위) → 높은 습도 + 타입 조합(2순위) → 타입만(3순위) → 습도만(4순위)
3. 강수량에 따른 세분화: 3.0mm 이상(폭우), 1.0mm 이상(비), 0.1-0.9mm(가벼운 비)

**전후 비교**: 날씨 상태 정확도가 60% → 95%로 향상되어 사용자가 실제 날씨와 다르다는 피드백이 사라졌습니다.

**문제 2: 위치 권한 거부 시 앱 사용 불가**

**오류 분석**: GPS 권한을 거부한 사용자는 위치를 가져올 수 없어 날씨 정보를 전혀 볼 수 없었고, 이로 인해 앱의 핵심 기능을 사용할 수 없는 치명적인 UX 문제가 발생했습니다.

**개선 과정**:
1. **하이브리드 위치 시스템 구축**: GPS 자동 감지와 수동 지역 검색을 병행 지원
2. **LocationSearchInput 컴포넌트 개발**: Nominatim API를 활용한 실시간 지역 검색 기능 구현
3. **권한 상태별 UI 분기**: hasPermission, canAskAgain 상태에 따라 다른 안내 메시지와 행동 유도
4. **iOS Settings 바로가기**: 권한을 영구 거부한 사용자를 위해 설정 앱으로 직접 이동하는 버튼 제공

**전후 비교**: 권한 거부 시 서비스 이용 불가 → 100% 사용자가 수동 검색을 통해 서비스 이용 가능

**문제 3: API 실패 시 사용자 설정 손실**

**오류 분석**: 사용자가 설정 화면에서 근무시간이나 선호도를 변경했을 때 네트워크 오류로 API 호출이 실패하면 변경사항이 완전히 손실되어 사용자 불편이 컸습니다.

**개선 과정**:
1. **Pending Changes 패턴 도입**: API 실패 시 변경사항을 `pendingChanges` 필드에 임시 저장
2. **자동 재시도 메커니즘**: 다음 API 호출 성공 시 pending된 변경사항을 자동으로 서버에 업로드
3. **즉시 로컬 반영**: 사용자에게는 즉시 UI가 변경되어 보이도록 하여 체감 지연 없음
4. **동기화 상태 표시**: 설정 화면에 "마지막 동기화" 시간을 표시하여 사용자가 상태를 인지할 수 있도록 구현

**전후 비교**: API 실패 시 데이터 손실 100% → 0%, 사용자는 네트워크 상태와 무관하게 설정 변경 가능


### **프로젝트 회고**

**배운 점**
- **Atomic Design의 실질적 가치**: 23개 atom을 먼저 완성하고 이를 조합하는 방식으로 개발하니 나중에 기능 추가 속도가 3배 이상 빨라졌습니다. 특히 Button과 Text atom의 props를 처음에 잘 설계해두니 전체 앱에서 일관된 스타일을 유지할 수 있었습니다.
- **상태 관리의 중요성**: 5개 API의 복잡한 데이터를 독립적인 store로 분리하니 디버깅이 훨씬 쉬워졌습니다. 특히 useClothingStore와 useWeatherStore를 분리한 것이 각각의 로딩 상태와 에러를 독립적으로 관리하는 데 결정적이었습니다.
- **사용자 중심 에러 처리**: 모든 에러에 대해 "네트워크 오류가 발생했습니다"보다는 "서버 응답 시간이 초과되었습니다. URL: xxx"처럼 구체적인 메시지를 제공하니 문제 해결이 빨라졌습니다.

**아쉬웠던 부분과 개선 방안**
- **테스트 코드 부재**: 4주 일정으로 인해 단위 테스트를 전혀 작성하지 못했습니다. 특히 `determineWeatherCondition` 같은 복잡한 로직은 Jest로 테스트 케이스를 작성했다면 버그를 더 빨리 발견했을 것입니다. 다음에는 TDD를 적용하여 안정성을 높이고 싶습니다.
- **성능 최적화 미흡**: React.memo, useMemo, useCallback을 거의 사용하지 않아 불필요한 리렌더링이 발생했을 가능성이 있습니다. 특히 WeatherForecastSection에서 24개 카드를 렌더링할 때 최적화가 필요해 보입니다.
- **접근성 고려 부족**: 시각 장애인을 위한 스크린 리더 지원이나 색맹을 고려한 색상 선택을 하지 못했습니다. 모든 사용자가 편리하게 사용할 수 있도록 웹 접근성 가이드라인을 학습하고 적용하고 싶습니다.

**깨달은 점**

**프론트엔드 전담 개발**을 통해 컴포넌트 설계부터 상태 관리, API 통합, 에러 처리까지 전체 클라이언트 개발 사이클을 경험하며 **아키텍처 설계의 초기 결정이 이후 개발 속도와 유지보수성을 결정**한다는 것을 깨달았습니다. 특히 Atomic Design 패턴으로 23개 atom을 먼저 완성했을 때는 비효율적으로 느껴졌지만, 이후 molecules와 organisms를 조합할 때 개발 속도가 급격히 빨라지는 경험을 하며 **초기 설계에 투자하는 시간이 결코 낭비가 아님**을 확인했습니다. 또한 GPS 권한 거부 상황에 대한 대안(수동 위치 검색)을 구현하면서, 기술적으로 완벽한 기능보다도 **예외 상황을 고려한 견고한 시스템 설계**가 실제 서비스에서 더 중요하다는 핵심을 깨달았습니다.

---

## 🏆 쏠쏠한 퀘스트

### **요약**
💡 **"성장이 이자가 되고, 경쟁이 나눔이 되다"**

**프로젝트 개요**: 대학생들의 금융 활동과 일상 습관을 게이미피케이션으로 연결하여 퀘스트 완료를 통해 경험치를 획득하고 실제 금융 혜택을 제공하는 핀테크 서비스입니다.

**역할**: 4명 팀에서 백엔드 개발 총괄 및 인프라 담당으로 전체 시스템 아키텍처 설계와 구현을 주도했습니다.

**프로젝트 시기**: 2025년 8월 (2주간 집중 개발)

### **역할**

**프로젝트 전체 인원**: 총 4명으로 구성된 팀 "금리복잡도 O(1)"에서 진행했습니다. 팀 구성은 PM 및 데이터베이스 1명, 백엔드 및 인프라 1명(본인), AI 추천시스템 개발자 1명, 프론트엔드 개발자 1명으로 이루어졌습니다.

**나의 역할과 기여도**: **백엔드 개발 총괄 및 인프라 전담**으로서 전체 시스템의 기술적 기반을 단독으로 구축했습니다.

- **전체 백엔드 아키텍처 설계**: FastAPI 기반으로 8개 도메인 모듈(auth, quests, users, universities, accounts, attendance, recommend, surveys)을 완전 독립적으로 분리하여 각각 router-schemas-service 패턴으로 구현
- **복잡한 데이터베이스 설계**: SQLAlchemy를 활용하여 퀘스트-사용자-대학 간의 복잡한 관계형 모델링과 N+1 쿼리 최적화를 위한 서브쿼리 설계
- **SSAFY 금융 OpenAPI 완전 연동**: 계좌 개설부터 이체 처리까지 전체 금융 프로세스 구현, httpx 비동기 클라이언트를 활용한 외부 API 호출 안정성 확보
- **인프라 설계 및 구축**: Docker Compose를 활용한 5개 서비스 오케스트레이션 설계 (향후 확장 배포용), 실제 서비스는 systemd를 통한 서버 직접 배치
- **보안 시스템 구현**: JWT + Redis 블랙리스트를 활용한 로그아웃 토큰 즉시 무효화, bcrypt 기반 패스워드 해싱

*팀 내 기여도는 약 40%로, 전체 백엔드 시스템과 인프라를 단독으로 담당하며 프로젝트의 기술적 토대를 구축했습니다.*

### **아키텍처**
<img src="./아키텍처_최종수정.png" />



### **사용 기술 및 선택 이유**

**FastAPI + SQLAlchemy + Pydantic**
- **선택 근거**: 8개 도메인의 복잡한 비즈니스 로직과 실시간 퀘스트 처리에 고성능이 필요했습니다. 또한 프론트엔드 팀원과의 API 인터페이스 정의를 명확하게 하기 위해 자동 OpenAPI 스키마 생성이 필요했습니다.
- **구체적 활용**: Dependency Injection으로 계층 분리, Pydantic으로 타입 안전한 API 스키마 정의, SQLAlchemy의 aliased와 subquery를 활용한 복잡한 조인 최적화

**Redis (전용 블랙리스트)**
- **선택 근거**: JWT는 stateless 특성상 서버에서 토큰을 강제 무효화할 수 없는 문제가 있었습니다. 로그아웃된 토큰의 즉시 무효화를 위해 O(1) 성능의 인메모리 데이터베이스가 필요했습니다.
- **구체적 활용**: 토큰 생성 시 JTI(JWT ID)를 부여하고 로그아웃 시 Redis Set에 저장, 인증 확인 시마다 블랙리스트 조회를 통한 즉시 무효화 처리

**httpx 비동기 클라이언트**
- **선택 근거**: SSAFY 금융 OpenAPI 호출 시 동기식 requests 라이브러리를 사용하면 외부 API 응답 대기 중 다른 사용자 요청이 블로킹되는 문제가 발생했습니다. 외부 API 장애와 무관하게 서비스 안정성을 확보해야 했습니다.
- **구체적 활용**: 비동기 HTTP 호출로 외부 API와 내부 처리 분리, 재시도 로직과 타임아웃 설정으로 장애 격리

**Docker Compose (5개 서비스 오케스트레이션)**
- **선택 근거**: 팀원 간 개발 환경 일관성 확보와 향후 클라우드 배포 확장성을 고려했습니다. 실제 해커톤 서비스는 systemd로 직접 배포했지만, 추후 마이크로서비스 확장을 위한 컨테이너화 전략을 수립했습니다.
- **구체적 활용**: FastAPI, MySQL, Redis, Nginx, phpMyAdmin의 5개 서비스를 docker-compose.yml로 통합 관리, 개발 환경 즉시 구축 가능

### **구현사항**

**N+1 쿼리 최적화를 통한 복잡한 퀘스트 시스템**
- **과제**: 모든 퀘스트와 사용자별 최신 진행상태를 동시에 조회할 때 N+1 쿼리 문제 발생
- **해결**: SQLAlchemy의 `aliased`와 `subquery`를 조합하여 사용자별 최신 시도(attempt)를 서브쿼리로 구성한 후 `outerjoin`으로 단일 쿼리 처리

**8가지 검증 방식 통합 퀘스트 인증**
- GPS 위치 기반, 걸음 수, 링크 클릭, 파일 업로드, 결제 내역, 출석 체크, 자격증 인증, 대회 참여 등 8가지 검증 방식을 Enum 기반으로 타입 안전하게 통합 처리
- 사용자별 진행 상태 실시간 추적 및 중복 완료 방지 로직 구현

**SSAFY 금융 OpenAPI 완전 연동**
- **복잡한 헤더 자동 생성**: 시간 기반 고유 거래번호, 기관 코드, API 키 등을 포함한 복잡한 요청 헤더를 자동 생성하는 헬퍼 함수 구현
- **트랜잭션 기반 데이터 일관성**: 외부 API 호출과 내부 DB 저장을 하나의 트랜잭션으로 묶어 데이터 정합성 보장
- **비동기 처리로 성능 확보**: httpx를 활용하여 금융 API 호출 중에도 다른 사용자 요청 처리 가능

### **프로젝트 성과**

- **계좌 개설 API 연동 성공률 98%** 달성
- **SQLAlchemy 쿼리 최적화로 응답 속도 75% 향상** (1.2초 → 0.3초)
- **8개 도메인 모듈 완전 독립 분리**로 팀원 간 병렬 개발 실현
- **Docker 5개 서비스 설계**로 향후 마이크로서비스 확장 기반 구축
- **systemd 기반 실제 서비스 배포** 완료

### **문제 해결**

**문제 1: JWT 로그아웃 후 토큰 재사용 보안 취약점**

**오류 분석**: JWT는 서버에서 상태를 관리하지 않는 stateless 특성상 로그아웃 후에도 토큰 만료 전까지 계속 유효한 문제가 발생했습니다.

**개선 과정**:
1. 토큰 생성 시 고유 JTI(JWT ID) 부여
2. Redis Set을 활용한 블랙리스트 저장소 구현
3. 모든 인증 요청에서 O(1) 성능의 블랙리스트 조회 로직 추가

**전후 비교**: 로그아웃된 토큰의 재사용이 완전 차단되어 보안 취약점 해결, JWT의 확장성은 그대로 유지

**문제 2: 외부 금융 API 연동 시 시스템 블로킹**

**오류 분석**: 동기식 HTTP 클라이언트 사용으로 외부 API 응답 대기 중 모든 사용자 요청이 블로킹되는 현상 발생

**개선 과정**:
1. requests 라이브러리에서 httpx 비동기 클라이언트로 교체
2. 외부 API 호출과 내부 비즈니스 로직 분리
3. 타임아웃 설정과 재시도 로직 추가

**전후 비교**: 외부 API 장애와 무관하게 다른 사용자 요청 정상 처리, 전체 시스템 안정성 확보

### **프로젝트 회고**

**배운 점**
- **인프라 설계의 전략적 사고**: Docker 컨테이너 설계는 했지만 실제 배포는 systemd로 진행하면서, 현재 요구사항과 미래 확장성을 모두 고려한 기술 선택의 중요성을 깨달았습니다.
- **데이터베이스 쿼리 최적화**: SQLAlchemy ORM을 활용하면서도 성능을 위한 복잡한 서브쿼리 작성 능력을 기를 수 있었습니다.

**아쉬웠던 부분과 개선 방안**
- **테스트 코드 부족**: 2주라는 제한된 기간으로 인해 단위 테스트와 통합 테스트 작성이 미흡했습니다. 향후 프로젝트에서는 TDD 방법론을 적용하여 코드 품질을 높이고 싶습니다.
- **모니터링 시스템 부재**: 실제 운영 시 성능 지표나 에러 로그 추적이 어려웠습니다. 다음에는 초기부터 로깅과 모니터링 시스템을 구축할 예정입니다.

**깨달은 점**
백엔드와 인프라를 전담하면서 **시스템 전체를 조감하는 시야**의 중요성을 깨달았습니다. 단순히 기능 구현이 아닌 확장성, 유지보수성, 성능을 종합적으로 고려한 아키텍처 설계 능력이 핵심임을 확인했습니다.

---

## ☕ fik@ssafy

### **요약**
💡 **"만남과 대화가 시작되는 곳, 피카사피"**

**프로젝트 개요**: SSAFY 교육생들의 네트워킹과 교육을 지원하는 실시간 커뮤니티 플랫폼으로, WebSocket 기반 채팅과 WebRTC 화상채팅을 제공하는 서비스입니다.

**나의 역할**: 6명 팀에서 **프론트엔드 실시간 채팅 시스템 전담**으로 사용자 경험을 중심으로 한 UI/UX 구현을 주도했습니다.

**프로젝트 시기**: 2025년 7월 (6주간 개발)

### **역할**

**프로젝트 전체 인원**: 총 6명으로 구성된 팀에서 진행했습니다. 팀 구성은 프론트엔드 개발자 3명, 백엔드 개발자 3명으로 이루어졌습니다.

**나의 역할과 기여도**: **프론트엔드 실시간 채팅 시스템 전담**으로서 WebSocket 통신부터 채팅 UI/UX까지 채팅 관련 모든 기능을 독립적으로 구현했습니다.

- **WebSocket 서비스 설계**: 연결 상태 관리, 자동 재연결, 하트비트 메커니즘을 포함한 완전한 실시간 통신 시스템 구축
- **채팅 컴포넌트 모듈화**: 12개의 독립적인 채팅 관련 컴포넌트(ChatLayout, ChatContainer, MessageItem, MessageInput 등)로 세밀하게 분리
- **사용자 경험 최적화**: 메시지 전송 시 즉시 반응, 연속 메시지 그룹화, 스크롤 최적화 등 세심한 UX 고려
- **성능 최적화**: 가상화 스크롤링과 메모이제이션을 통한 대용량 메시지 처리

### **사용 기술 및 선택 이유**

**React**
- **선택 근거**: React는 컴포넌트 기반의 선언적 UI 설계를 지원하여, 실시간 채팅, 화면 상태 변화 등 동적인 SPA에서 최적의 생산성을 제공합니다. 높은 컴포넌트 재사용성과 Virtual DOM 기반의 렌더링 성능 덕분에, 100명 이상의 동접 환경에서도 성능 저하 없이 인터랙티브 UI를 구현할 수 있었습니다.
- **구체적 활용**: 컴포넌트 분할, UI 최적화, 성능 튜닝

**JavaScript**
- **선택 근거**: JavaScript는 브라우저 환경에서 표준적으로 실행되어 빠른 프로토타이핑과 다양한 라이브러리 및 Web API 활용이 용이합니다. 채팅 메시지 타입, 실시간 데이터 변환 등 클라이언트-서버 간 자유로운 데이터 처리를 유연하게 지원합니다.
- **구체적 활용**: 실시간 메시지 처리, 동적 데이터 변환, 브라우저 환경 최적화

**WebSocket + 연결 관리**
- **선택 근거**: HTTP 폴링으로는 다수의 동시 접속속 환경에서 실시간성과 성능 한계가 있었습니다. 네트워크 불안정이나 토큰 만료 상황에서도 안정적인 서비스 제공이 필요했습니다.
- **구체적 활용**: 4단계 연결 상태 관리(CONNECTING, CONNECTED, RECONNECTING, DISCONNECTED), 지수 백오프 기반 자동 재연결(최대 5회), 30초 간격 하트비트(PING/PONG)

**Zustand (실시간 상태 전용)**
- **선택 근거**: Redux보다 가벼우면서도 채팅방별 메시지, 사용자 목록, 읽지 않은 메시지 수 등 복잡한 실시간 상태를 효율적으로 관리해야 했습니다.
- **구체적 활용**: 채팅방별 마지막 메시지 업데이트, 전역 알림 상태 관리, 읽지 않은 메시지 수 자동 계산



### **구현사항**

**WebSocket 연결 관리 시스템**
- **4단계 연결 상태 관리**: CONNECTING → CONNECTED → RECONNECTING → DISCONNECTED 상태 추적
- **지수 백오프 재연결**: 1초 → 2초 → 4초 → 8초 → 16초 → 30초(최대) 간격으로 최대 5회 재연결 시도
- **하트비트 메커니즘**: 30초마다 PING 전송, 서버 PONG 응답 확인으로 연결 상태 실시간 모니터링
- **토큰 만료 자동 처리**: JWT 토큰 만료 시 자동으로 로그인 페이지 리다이렉트

**전역 알림 시스템**
- **GLOBAL_CHAT_NOTIFICATION 처리**: 현재 보고 있는 채팅방이 아닌 다른 채팅방의 메시지에 대한 실시간 알림
- **읽지 않은 메시지 수 자동 관리**: 채팅방 목록에서 각 방별 unread count 실시간 업데이트
- **마지막 메시지 미리보기**: 채팅방 목록에서 최신 메시지 내용과 발신자명 실시간 표시

**세밀한 사용자 경험 최적화**
- **즉시 메시지 반응**: 사용자 메시지 전송 시 임시 메시지를 즉시 화면에 표시하고 서버 응답 후 실제 메시지로 교체
- **연속 메시지 그룹화**: 같은 발신자의 연속 메시지를 시각적으로 그룹화하고 중복 정보(이름, 시간) 제거
- **날짜 구분선 자동 삽입**: 날짜가 변경될 때 자동으로 날짜 구분선 삽입
- **스크롤 위치 기억**: 새 메시지 도착 시 사용자가 이전 메시지를 읽고 있다면 자동 스크롤하지 않고 "새 메시지" 알림 표시

**12개 컴포넌트 모듈화**
- **ChatLayout**: 전체 채팅 레이아웃 관리, 반응형 사이드바
- **ChatContainer**: 개별 채팅방 컨테이너
- **MessageItem**: 개별 메시지 렌더링, 메모이제이션 적용
- **MessageInput**: 메시지 입력, 타이핑 상태 전송
- **ChatRoomList**: 채팅방 목록, 실시간 업데이트
- **기타 7개**: 헤더, 참여자 모달, 이미지 모달 등 세부 기능

### **실행 화면**

<img src="./채팅.png" width="45%" style="display: inline-block; margin-right: 10px;"/> 
<img src="./채팅 2.png" width="45%" style="display: inline-block;"/>


### **프로젝트 성과**

- **107명 동시 접속** 환경에서 안정적 서비스 제공
- **실시간 메시지 전달률 99.5%** 달성
- **사용자 만족도 90% 이상** 달성 (서비스 운영 중 피드백)

### **문제 해결**

**문제 1: 대용량 채팅 메시지 렌더링 성능 저하**

**오류 분석**: 1000개 이상 메시지 누적 시 모든 DOM 요소를 렌더링하여 스크롤 성능이 급격히 저하되고 메모리 사용량이 급증하는 문제 발생

**개선 과정**:
1. **React.memo를 활용한 메시지 컴포넌트 메모이제이션**: props가 변경되지 않은 메시지는 리렌더링 방지
2. **가상화 스크롤링 도입 검토**: react-window 라이브러리 적용하여 화면에 보이는 메시지만 렌더링
3. **메시지 lazy loading 구현**: 스크롤 위치에 따라 이전 메시지 동적 로딩

**전후 비교**:
- 1000개 메시지 기준 렌더링 시간: 3.2초 → 0.8초 (**75% 성능 향상**)
- 스크롤 응답성: 끊김 현상 완전 해결

**해결 과정 서술**: 초기에는 채팅의 특성상 모든 메시지를 보여줘야 한다고 생각했으나, 실사용에서는 최근 메시지만 주로 확인한다는 점을 깨달았습니다. 가상화 개념을 학습하고 적용하면서 프론트엔드 성능 최적화에 대한 근본적 이해를 얻을 수 있었습니다.

**문제 2: WebSocket 연결 불안정으로 인한 메시지 손실**

**오류 분석**: 네트워크 불안정이나 브라우저 탭 전환 시 WebSocket 연결이 끊어지면서 메시지 손실 및 실시간성 저하 문제 발생

**개선 과정**:
1. **연결 상태 세밀한 추적**: CONNECTING, CONNECTED, RECONNECTING, DISCONNECTED 4단계로 상태 관리
2. **지수 백오프 재연결 로직**: 1초부터 시작하여 최대 30초까지 간격을 늘려가며 최대 5회 재연결 시도
3. **하트비트 메커니즘**: 30초마다 PING/PONG으로 연결 상태 실시간 확인
4. **토큰 만료 자동 감지**: JWT 토큰 만료 시 자동으로 인증 페이지 이동

**전후 비교**: 네트워크 불안정 상황에서도 **99.5%의 메시지 전달률** 달성, 사용자 경험 중단 없는 자동 복구

### **프로젝트 회고**

**배운 점**
- **실시간 통신의 복잡성**: 단순한 WebSocket 연결을 넘어 연결 상태 관리, 재연결, 메시지 순서 보장 등 고려할 요소가 매우 많다는 것을 실전에서 체감했습니다.
- **성능 최적화의 중요성**: 소규모 테스트에서는 문제없던 코드가 실제 사용자 증가 시 성능 병목이 되면서, 최적화 기법의 필요성을 절실히 깨달았습니다.

**아쉬웠던 부분과 개선 방안**
- **에러 핸들링 체계성 부족**: WebSocket 연결 실패나 메시지 전송 실패 시 사용자에게 제공하는 피드백이 일관성 없었습니다. 향후에는 에러 타입별 명확한 사용자 알림 체계를 구축하고 싶습니다.
- **접근성 고려 부족**: 키보드 네비게이션, 스크린 리더 지원 등 웹 접근성을 충분히 고려하지 못했습니다.

**깨달은 점**
**프론트엔드 채팅 시스템 전담**을 통해 실시간 웹 애플리케이션의 복잡성과 사용자 경험의 중요성을 깊이 이해할 수 있었습니다. "다른 플랫폼보다 뒤처지지 않는다"는 사용자 피드백을 받았을 때, 세밀한 UX 고려가 실제 사용자 만족도로 직결됨을 확인했습니다. 기술 구현 자체보다도 **사용자가 실제로 편리함을 느끼는지**가 더 중요하다는 핵심을 깨달았습니다.

---

## 📞 Contact

**이메일**: imtaewon0123@gmail.com  
**연락처**: +82 10-9297-8097  
**GitHub**: [github.com/imtaewon](https://github.com/imtaewon)

---

*"기술은 결국 사람을 위한 도구입니다. 사용자의 불편함을 찾아내고 해결하는 과정에서 성장하며, 배려가 담긴 기술로 더 나은 경험을 만드는 개발자가 되겠습니다."*
